{
  "meta": {
    "project": "Discord Voice Recorder Bot",
    "module": "Audio Engine (Phase 2)",
    "version": "2.2.0",
    "type": "Architecture Contract",
    "last_updated": "RTP Timestamp Synchronization & Packet Monitoring"
  },
  "global_settings": {
    "audio": {
      "sample_rate": 48000,
      "channels": 2,
      "bitrate_chunk": "64k",
      "bitrate_master": "128k",
      "codec": "libmp3lame",
      "format": "mp3",
      "pcm_frame_size": 960
    },
    "timings": {
      "chunk_duration_ms": 300000,
      "idle_timeout_ms": 900000,
      "silence_threshold_ticks": 960,
      "rtp_clock_rate": 48000
    }
  },
  "data_structures": {
    "typescript_interfaces": [
      {
        "name": "ActiveStream",
        "description": "State of a currently recording stream.",
        "fields": {
          "out": "fs.WriteStream",
          "decoder": "prism.opus.Decoder",
          "encoder": "prism.FFmpeg",
          "silenceInjector": "RtpSilenceInjector",
          "currentPath": "string",
          "connectionStartTime": "number",
          "sessionId": "string",
          "chunks": "string[]"
        }
      },
      {
        "name": "RtpPacketInfo",
        "description": "Metadata extracted from raw UDP packets.",
        "fields": {
          "timestamp": "number",
          "sequence": "number",
          "size": "number"
        }
      }
    ],
    "state_maps": {
      "activeStreams": "Map<string, ActiveStream>",
      "connectionErrors": "Map<string, number>",
      "pausedGuilds": "Set<string>",
      "guildMonitors": "Map<string, PacketMonitor>"
    }
  },
  "components": {
    "packet_monitor": {
      "class_name": "PacketMonitor",
      "extends": "EventEmitter",
      "logic": "Sniffs UDP socket for RTP packets, parses headers (including 0x90 extension), emits 'packet' event with timestamp/seq.",
      "purpose": "Provide ground-truth timing data independent of network jitter."
    },
    "rtp_silence_injector": {
      "class_name": "RtpSilenceInjector",
      "extends": "Transform",
      "logic": "Matches decrypted Opus chunks with RTP packet metadata. Injects Opus silence frames (0xF8, 0xFF, 0xFE) when RTP timestamp delta > 960.",
      "calculation": "missingFrames = floor(delta / 960) - 1"
    },
    "session_mixer": {
      "module": "sessionMixer.ts",
      "function": "mixSessionAudio(sessionId)",
      "logic": "Iterative batch mixing of all session recordings retrieved from DB/Oracle.",
      "features": [
        "Automatic download of missing files from Oracle",
        "Batch processing (50 files at a time) to save RAM",
        "WAV accumulation for quality preservation",
        "Final MP3 conversion with Loudnorm"
      ]
    }
  },
  "workflows": {
    "connect_session": {
      "trigger": "Bot joins channel",
      "action": "Check DB for session start time. If missing, createSession(sessionId, now) in DB. Attach PacketMonitor."
    },
    "stream_rotation": {
      "trigger": "Every 5 minutes OR Idle Timeout",
      "actions": [
        "Unpipe Decoder from OldEncoder",
        "End OldEncoder",
        "On OldOut finish -> Upload to Oracle /chunks/",
        "Create NewEncoder & NewFile",
        "Pipe Decoder -> NewEncoder -> NewFile"
      ]
    },
    "fragment_merge": {
      "trigger": "User disconnect OR Stream Close",
      "context": "User might reconnect later. This handles only the current connection span.",
      "steps": [
        "Filter valid local chunks",
        "Generate list.txt for FFmpeg concat demuxer",
        "Execute FFmpeg Merge (Concat ONLY - No normalization applied here)",
        "Process Final File: DB Insert, Upload to Oracle /full/, Queue Transcription",
        "Delete local chunks"
      ]
    },
    "master_mix": {
      "trigger": "Bot disconnect (End of Session)",
      "steps": [
        "Wait for all active stream closures (Promise.all)",
        "Invoke mixSessionAudio(sessionId)",
        "Mixer downloads missing files from Oracle if needed",
        "Mixer generates MASTER-{sessionId}.mp3",
        "Upload result to Oracle /master/",
        "Log success"
      ]
    }
  },
  "ffmpeg_commands": {
    "merge_fragment": {
      "description": "Concatenates chunks quickly without altering audio levels.",
      "template": "ffmpeg -f concat -safe 0 -i {listPath} -c:a libmp3lame -b:a 64k {outputPath}",
      "execution_method": "child_process.exec"
    },
    "master_mix_iterative": {
      "description": "Mixes batch of files into an accumulator WAV.",
      "inputs": "Accumulator (optional) + Batch Files",
      "filter_complex_logic": {
        "step_1_delay": "[{i}]adelay={delay}|{delay}[s{i}]",
        "step_2_mix": "[s0]...[sN]amix=inputs={count}:dropout_transition=0:normalize=0[out]"
      },
      "output_args": [
        "-map", "[out]",
        "-ac", "2",
        "-c:a", "pcm_s16le",
        "-y", "{destination}"
      ],
      "execution_method": "child_process.spawn"
    }
  },
  "file_naming": {
    "chunk": "recordings/{userId}-{timestamp}.mp3",
    "fragment": "recordings/FULL-{userId}-{timestamp}.mp3",
    "master": "recordings/MASTER-{sessionId}.mp3",
    "list_file": "recordings/list-{sessionId}-{userId}-{timestamp}.txt"
  },
  "oracle_paths": {
    "chunks": "recordings/{sessionId}/chunks/{filename}",
    "fragments": "recordings/{sessionId}/full/{filename}",
    "master": "recordings/{sessionId}/master/{filename}"
  }
}
